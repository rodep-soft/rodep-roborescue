[0.029s] Invoking command in '/root/working/rodep_ros2/yano_ws/build/driver': AMENT_PREFIX_PATH=/root/working/rodep_ros2/yano_ws/install/driver:/root/working/rodep_ros2/yano_ws/install/custom_interfaces:${AMENT_PREFIX_PATH} CMAKE_PREFIX_PATH=/root/working/rodep_ros2/yano_ws/install/driver:/root/working/rodep_ros2/yano_ws/install/custom_interfaces LD_LIBRARY_PATH=/root/working/rodep_ros2/yano_ws/install/custom_interfaces/lib:${LD_LIBRARY_PATH} PYTHONPATH=/root/working/rodep_ros2/yano_ws/install/custom_interfaces/local/lib/python3.10/dist-packages:${PYTHONPATH} /usr/bin/ctest -C Release -D ExperimentalTest --no-compress-output -V --force-new-ctest-process --output-on-failure
[0.038s] UpdateCTestConfiguration  from :/root/working/rodep_ros2/yano_ws/build/driver/CTestConfiguration.ini
[0.039s] Parse Config file:/root/working/rodep_ros2/yano_ws/build/driver/CTestConfiguration.ini
[0.039s]    Site: cf33789d9224
[0.039s]    Build name: (empty)
[0.039s]  Add coverage exclude regular expressions.
[0.040s] Create new tag: 20250307-1051 - Experimental
[0.040s] UpdateCTestConfiguration  from :/root/working/rodep_ros2/yano_ws/build/driver/CTestConfiguration.ini
[0.040s] Parse Config file:/root/working/rodep_ros2/yano_ws/build/driver/CTestConfiguration.ini
[0.040s] Test project /root/working/rodep_ros2/yano_ws/build/driver
[0.040s] Constructing a list of tests
[0.041s] Done constructing a list of tests
[0.041s] Updating test list for fixtures
[0.041s] Added 0 tests to meet fixture requirements
[0.041s] Checking test dependency graph...
[0.041s] Checking test dependency graph end
[0.041s] test 1
[0.041s]     Start 1: cppcheck
[0.041s] 
[0.041s] 1: Test command: /usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/cppcheck.xunit.xml" "--package-name" "driver" "--output-file" "/root/working/rodep_ros2/yano_ws/build/driver/ament_cppcheck/cppcheck.txt" "--command" "/opt/ros/humble/bin/ament_cppcheck" "--xunit-file" "/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/cppcheck.xunit.xml"
[0.041s] 1: Test timeout computed to be: 300
[0.112s] 1: -- run_test.py: invoking following command in '/root/working/rodep_ros2/yano_ws/src/driver':
[0.112s] 1:  - /opt/ros/humble/bin/ament_cppcheck --xunit-file /root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/cppcheck.xunit.xml
[0.208s] 1: cppcheck 2.7 has known performance issues and therefore will not be used, set the AMENT_CPPCHECK_ALLOW_SLOW_VERSIONS environment variable to override this.
[0.221s] 1: -- run_test.py: return code 0
[0.221s] 1: -- run_test.py: verify result file '/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/cppcheck.xunit.xml'
[0.232s] 1/4 Test #1: cppcheck .........................   Passed    0.19 sec
[0.232s] test 2
[0.232s]     Start 2: lint_cmake
[0.232s] 
[0.232s] 2: Test command: /usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/lint_cmake.xunit.xml" "--package-name" "driver" "--output-file" "/root/working/rodep_ros2/yano_ws/build/driver/ament_lint_cmake/lint_cmake.txt" "--command" "/opt/ros/humble/bin/ament_lint_cmake" "--xunit-file" "/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/lint_cmake.xunit.xml"
[0.233s] 2: Test timeout computed to be: 60
[0.305s] 2: -- run_test.py: invoking following command in '/root/working/rodep_ros2/yano_ws/src/driver':
[0.305s] 2:  - /opt/ros/humble/bin/ament_lint_cmake --xunit-file /root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/lint_cmake.xunit.xml
[0.391s] 2: CMakeLists.txt:23: Tab found; please use spaces [whitespace/tabs]
[0.392s] 2: CMakeLists.txt:23: Line ends in whitespace [whitespace/eol]
[0.392s] 2: 
[0.392s] 2: 
[0.392s] 2: 2 errors
[0.404s] 2: -- run_test.py: return code 1
[0.404s] 2: -- run_test.py: verify result file '/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/lint_cmake.xunit.xml'
[0.415s] 2/4 Test #2: lint_cmake .......................***Failed    0.18 sec
[0.415s] -- run_test.py: invoking following command in '/root/working/rodep_ros2/yano_ws/src/driver':
[0.415s]  - /opt/ros/humble/bin/ament_lint_cmake --xunit-file /root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/lint_cmake.xunit.xml
[0.415s] CMakeLists.txt:23: Tab found; please use spaces [whitespace/tabs]
[0.415s] CMakeLists.txt:23: Line ends in whitespace [whitespace/eol]
[0.415s] 
[0.416s] 
[0.416s] 2 errors
[0.416s] -- run_test.py: return code 1
[0.416s] -- run_test.py: verify result file '/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/lint_cmake.xunit.xml'
[0.416s] 
[0.416s] test 3
[0.416s]     Start 3: uncrustify
[0.416s] 
[0.416s] 3: Test command: /usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/uncrustify.xunit.xml" "--package-name" "driver" "--output-file" "/root/working/rodep_ros2/yano_ws/build/driver/ament_uncrustify/uncrustify.txt" "--command" "/opt/ros/humble/bin/ament_uncrustify" "--xunit-file" "/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/uncrustify.xunit.xml"
[0.416s] 3: Test timeout computed to be: 60
[0.489s] 3: -- run_test.py: invoking following command in '/root/working/rodep_ros2/yano_ws/src/driver':
[0.489s] 3:  - /opt/ros/humble/bin/ament_uncrustify --xunit-file /root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/uncrustify.xunit.xml
[0.603s] 3: Code style divergence in file 'src/driver.cpp':
[0.603s] 3: 
[0.603s] 3: --- src/driver.cpp
[0.603s] 3: +++ src/driver.cpp.uncrustify
[0.604s] 3: @@ -6 +6 @@
[0.604s] 3: -#include <std_msgs/msg/bool.hpp> 
[0.604s] 3: +#include <std_msgs/msg/bool.hpp>
[0.604s] 3: @@ -27 +27,2 @@
[0.604s] 3: -class RoboclawDriver {
[0.604s] 3: +class RoboclawDriver
[0.605s] 3: +{
[0.605s] 3: @@ -29,34 +30,39 @@
[0.605s] 3: -    explicit RoboclawDriver(const string& port) : io(), serial(io, port) {
[0.605s] 3: -        try {
[0.605s] 3: -            serial.set_option(serial_port_base::baud_rate(SERIAL_BAUD_RATE));
[0.605s] 3: -            serial.set_option(serial_port_base::character_size(8));
[0.606s] 3: -            serial.set_option(serial_port_base::parity(serial_port_base::parity::none));
[0.606s] 3: -            serial.set_option(serial_port_base::stop_bits(serial_port_base::stop_bits::one));
[0.606s] 3: -            serial.set_option(serial_port_base::flow_control(serial_port_base::flow_control::none));
[0.606s] 3: -        } catch (const boost::system::system_error& e) {
[0.607s] 3: -            throw runtime_error("Failed to configure serial port: " + string(e.what()));
[0.607s] 3: -        }
[0.607s] 3: -    }
[0.607s] 3: -
[0.607s] 3: -    bool setMotorVelocity(int command, double counts_per_sec) {
[0.607s] 3: -        vector<uint8_t> data = {ROBOCLAW_ADDRESS, static_cast<uint8_t>(command)};
[0.607s] 3: -        appendInt32(data, static_cast<int>(counts_per_sec));
[0.607s] 3: -        appendCRC(data);
[0.608s] 3: -        return sendRoboclawCommand(data);
[0.608s] 3: -    }
[0.608s] 3: -
[0.608s] 3: -    bool setPIDConstants(int command, int K_p, int K_i, int K_d, int qpps) {
[0.610s] 3: -        vector<uint8_t> data = {ROBOCLAW_ADDRESS, static_cast<uint8_t>(command)};
[0.610s] 3: -        appendInt32(data, K_d);
[0.610s] 3: -        appendInt32(data, K_p);
[0.611s] 3: -        appendInt32(data, K_i);
[0.611s] 3: -        appendInt32(data, qpps);
[0.611s] 3: -        appendCRC(data);
[0.611s] 3: -        return sendRoboclawCommand(data);
[0.611s] 3: -    }
[0.611s] 3: -
[0.611s] 3: -    bool resetEncoders() {
[0.611s] 3: -        vector<uint8_t> data = {ROBOCLAW_ADDRESS, RESET_QUAD_ENCODER};
[0.611s] 3: -        appendCRC(data);
[0.612s] 3: -        return sendRoboclawCommand(data);
[0.612s] 3: -    }
[0.612s] 3: +  explicit RoboclawDriver(const string & port)
[0.612s] 3: +  : io(), serial(io, port)
[0.612s] 3: +  {
[0.612s] 3: +    try {
[0.612s] 3: +      serial.set_option(serial_port_base::baud_rate(SERIAL_BAUD_RATE));
[0.612s] 3: +      serial.set_option(serial_port_base::character_size(8));
[0.612s] 3: +      serial.set_option(serial_port_base::parity(serial_port_base::parity::none));
[0.612s] 3: +      serial.set_option(serial_port_base::stop_bits(serial_port_base::stop_bits::one));
[0.612s] 3: +      serial.set_option(serial_port_base::flow_control(serial_port_base::flow_control::none));
[0.612s] 3: +    } catch (const boost::system::system_error & e) {
[0.612s] 3: +      throw runtime_error("Failed to configure serial port: " + string(e.what()));
[0.612s] 3: +    }
[0.613s] 3: +  }
[0.613s] 3: +
[0.613s] 3: +  bool setMotorVelocity(int command, double counts_per_sec)
[0.613s] 3: +  {
[0.613s] 3: +    vector<uint8_t> data = {ROBOCLAW_ADDRESS, static_cast<uint8_t>(command)};
[0.613s] 3: +    appendInt32(data, static_cast<int>(counts_per_sec));
[0.613s] 3: +    appendCRC(data);
[0.613s] 3: +    return sendRoboclawCommand(data);
[0.613s] 3: +  }
[0.613s] 3: +
[0.614s] 3: +  bool setPIDConstants(int command, int K_p, int K_i, int K_d, int qpps)
[0.614s] 3: +  {
[0.614s] 3: +    vector<uint8_t> data = {ROBOCLAW_ADDRESS, static_cast<uint8_t>(command)};
[0.614s] 3: +    appendInt32(data, K_d);
[0.614s] 3: +    appendInt32(data, K_p);
[0.614s] 3: +    appendInt32(data, K_i);
[0.614s] 3: +    appendInt32(data, qpps);
[0.614s] 3: +    appendCRC(data);
[0.614s] 3: +    return sendRoboclawCommand(data);
[0.615s] 3: +  }
[0.615s] 3: +
[0.615s] 3: +  bool resetEncoders()
[0.615s] 3: +  {
[0.615s] 3: +    vector<uint8_t> data = {ROBOCLAW_ADDRESS, RESET_QUAD_ENCODER};
[0.615s] 3: +    appendCRC(data);
[0.615s] 3: +    return sendRoboclawCommand(data);
[0.615s] 3: +  }
[0.615s] 3: @@ -65,39 +71,45 @@
[0.615s] 3: -    io_service io;
[0.615s] 3: -    serial_port serial;
[0.615s] 3: -
[0.615s] 3: -    bool sendRoboclawCommand(const vector<uint8_t>& data) {
[0.616s] 3: -        try {
[0.616s] 3: -            write(serial, buffer(data));
[0.616s] 3: -            uint8_t response;
[0.616s] 3: -            read(serial, buffer(&response, 1));
[0.616s] 3: -            RCLCPP_DEBUG(rclcpp::get_logger("RoboclawDriver"), "Received Response: 0x%02X", response);
[0.616s] 3: -            return true;
[0.616s] 3: -        } catch (const boost::system::system_error& e) {
[0.616s] 3: -            RCLCPP_ERROR(rclcpp::get_logger("RoboclawDriver"), "Serial Communication Error: %s", e.what());
[0.616s] 3: -            return false;
[0.616s] 3: -        }
[0.616s] 3: -    }
[0.616s] 3: -
[0.616s] 3: -    uint16_t calculateCRC(const vector<uint8_t>& data) {
[0.616s] 3: -        uint16_t crc = 0;
[0.616s] 3: -        for (auto byte : data) {
[0.616s] 3: -            crc ^= static_cast<uint16_t>(byte) << 8;
[0.617s] 3: -            for (int i = 0; i < 8; i++) {
[0.617s] 3: -                crc = (crc & 0x8000) ? (crc << 1) ^ 0x1021 : (crc << 1);
[0.617s] 3: -            }
[0.617s] 3: -        }
[0.617s] 3: -        return crc;
[0.617s] 3: -    }
[0.617s] 3: -
[0.617s] 3: -    // CRCËøΩÂä†
[0.617s] 3: -    void appendCRC(vector<uint8_t>& data) {
[0.617s] 3: -        uint16_t crc = calculateCRC(data);
[0.617s] 3: -        data.push_back(static_cast<uint8_t>(crc >> 8));
[0.617s] 3: -        data.push_back(static_cast<uint8_t>(crc & 0xFF));
[0.617s] 3: -    }
[0.617s] 3: -
[0.617s] 3: -    void appendInt32(vector<uint8_t>& data, int value) {
[0.617s] 3: -        for (int i = 3; i >= 0; --i) {
[0.617s] 3: -            data.push_back(static_cast<uint8_t>((value >> (8 * i)) & 0xFF));
[0.618s] 3: -        }
[0.618s] 3: -    }
[0.618s] 3: +  io_service io;
[0.618s] 3: +  serial_port serial;
[0.618s] 3: +
[0.618s] 3: +  bool sendRoboclawCommand(const vector<uint8_t> & data)
[0.618s] 3: +  {
[0.618s] 3: +    try {
[0.618s] 3: +      write(serial, buffer(data));
[0.618s] 3: +      uint8_t response;
[0.618s] 3: +      read(serial, buffer(&response, 1));
[0.618s] 3: +      RCLCPP_DEBUG(rclcpp::get_logger("RoboclawDriver"), "Received Response: 0x%02X", response);
[0.618s] 3: +      return true;
[0.619s] 3: +    } catch (const boost::system::system_error & e) {
[0.619s] 3: +      RCLCPP_ERROR(
[0.619s] 3: +        rclcpp::get_logger("RoboclawDriver"), "Serial Communication Error: %s",
[0.619s] 3: +        e.what());
[0.619s] 3: +      return false;
[0.619s] 3: +    }
[0.619s] 3: +  }
[0.619s] 3: +
[0.620s] 3: +  uint16_t calculateCRC(const vector<uint8_t> & data)
[0.620s] 3: +  {
[0.620s] 3: +    uint16_t crc = 0;
[0.620s] 3: +    for (auto byte : data) {
[0.620s] 3: +      crc ^= static_cast<uint16_t>(byte) << 8;
[0.620s] 3: +      for (int i = 0; i < 8; i++) {
[0.620s] 3: +        crc = (crc & 0x8000) ? (crc << 1) ^ 0x1021 : (crc << 1);
[0.620s] 3: +      }
[0.620s] 3: +    }
[0.621s] 3: +    return crc;
[0.621s] 3: +  }
[0.621s] 3: +
[0.621s] 3: +  // CRCËøΩÂä†
[0.621s] 3: +  void appendCRC(vector<uint8_t> & data)
[0.621s] 3: +  {
[0.621s] 3: +    uint16_t crc = calculateCRC(data);
[0.621s] 3: +    data.push_back(static_cast<uint8_t>(crc >> 8));
[0.621s] 3: +    data.push_back(static_cast<uint8_t>(crc & 0xFF));
[0.622s] 3: +  }
[0.622s] 3: +
[0.622s] 3: +  void appendInt32(vector<uint8_t> & data, int value)
[0.622s] 3: +  {
[0.622s] 3: +    for (int i = 3; i >= 0; --i) {
[0.622s] 3: +      data.push_back(static_cast<uint8_t>((value >> (8 * i)) & 0xFF));
[0.622s] 3: +    }
[0.622s] 3: +  }
[0.622s] 3: @@ -107 +119,2 @@
[0.622s] 3: -class Driver : public rclcpp::Node {
[0.622s] 3: +class Driver : public rclcpp::Node
[0.622s] 3: +{
[0.623s] 3: @@ -109,22 +122,25 @@
[0.623s] 3: -    Driver() : Node("driver"), roboclaw("/dev/ttyACM0") { 
[0.623s] 3: -        declare_parameter("crawler_circumference", 0.39);
[0.623s] 3: -        declare_parameter("counts_per_rev", 256); // quad pulses per rev = counts per rev
[0.623s] 3: -        declare_parameter("gearhead_ratio", 66); // Ê∏õÈÄüÊØî
[0.623s] 3: -        declare_parameter("pulley_ratio", 2);
[0.623s] 3: -
[0.623s] 3: -        crawler_circumference_ = get_parameter("crawler_circumference").as_double();
[0.623s] 3: -        counts_per_rev_ = get_parameter("counts_per_rev").as_int();
[0.623s] 3: -        gearhead_ratio_ = get_parameter("gearhead_ratio").as_int();
[0.623s] 3: -        pulley_ratio_ = get_parameter("pulley_ratio").as_int();
[0.623s] 3: -
[0.624s] 3: -        // velocity„Çíqpps„Å´Â§âÊèõ„Åô„ÇãÈöõ„Å´Áî®„ÅÑ„ÇãÂÆöÊï∞
[0.624s] 3: -        counts_per_meter_ = (counts_per_rev_ * gearhead_ratio_ * pulley_ratio_) / crawler_circumference_;
[0.624s] 3: -
[0.624s] 3: -        subscription_ = create_subscription<custom_interfaces::msg::DriverVelocity>(
[0.624s] 3: -            "/operator", 10, bind(&Driver::driver_callback, this, _1));
[0.624s] 3: -
[0.624s] 3: -        estop_subscription_ = create_subscription<std_msgs::msg::Bool>(
[0.624s] 3: -            "/emergency_stop", 10, bind(&Driver::estop_callback, this, _1));
[0.624s] 3: -
[0.624s] 3: -        init();
[0.624s] 3: -    }
[0.624s] 3: +  Driver()
[0.624s] 3: +  : Node("driver"), roboclaw("/dev/ttyACM0")
[0.624s] 3: +  {
[0.624s] 3: +    declare_parameter("crawler_circumference", 0.39);
[0.624s] 3: +    declare_parameter("counts_per_rev", 256);     // quad pulses per rev = counts per rev
[0.625s] 3: +    declare_parameter("gearhead_ratio", 66);     // Ê∏õÈÄüÊØî
[0.625s] 3: +    declare_parameter("pulley_ratio", 2);
[0.625s] 3: +
[0.625s] 3: +    crawler_circumference_ = get_parameter("crawler_circumference").as_double();
[0.625s] 3: +    counts_per_rev_ = get_parameter("counts_per_rev").as_int();
[0.625s] 3: +    gearhead_ratio_ = get_parameter("gearhead_ratio").as_int();
[0.625s] 3: +    pulley_ratio_ = get_parameter("pulley_ratio").as_int();
[0.625s] 3: +
[0.625s] 3: +    // velocity„Çíqpps„Å´Â§âÊèõ„Åô„ÇãÈöõ„Å´Áî®„ÅÑ„ÇãÂÆöÊï∞
[0.625s] 3: +    counts_per_meter_ = (counts_per_rev_ * gearhead_ratio_ * pulley_ratio_) /
[0.625s] 3: +      crawler_circumference_;
[0.625s] 3: +
[0.625s] 3: +    subscription_ = create_subscription<custom_interfaces::msg::DriverVelocity>(
[0.626s] 3: +      "/operator", 10, bind(&Driver::driver_callback, this, _1));
[0.626s] 3: +
[0.626s] 3: +    estop_subscription_ = create_subscription<std_msgs::msg::Bool>(
[0.626s] 3: +      "/emergency_stop", 10, bind(&Driver::estop_callback, this, _1));
[0.626s] 3: +
[0.626s] 3: +    init();
[0.626s] 3: +  }
[0.626s] 3: @@ -133,53 +149,57 @@
[0.626s] 3: -    RoboclawDriver roboclaw;
[0.626s] 3: -    double crawler_circumference_;
[0.626s] 3: -    int counts_per_rev_;
[0.626s] 3: -    int gearhead_ratio_;
[0.626s] 3: -    int pulley_ratio_;
[0.626s] 3: -    double counts_per_meter_;
[0.626s] 3: -    bool estop_active_ = false;  // E-stop state
[0.626s] 3: -
[0.627s] 3: -    rclcpp::Subscription<custom_interfaces::msg::DriverVelocity>::SharedPtr subscription_;
[0.627s] 3: -    rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr estop_subscription_;
[0.627s] 3: -
[0.627s] 3: -    double velocity_to_counts_per_sec(double velocity) const {
[0.627s] 3: -        return velocity * counts_per_meter_;
[0.627s] 3: -    }
[0.627s] 3: -
[0.627s] 3: -    void init() {
[0.627s] 3: -        roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, 0);
[0.627s] 3: -        roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, 0);
[0.627s] 3: -        roboclaw.setPIDConstants(M1_SET_PID_CONSTANTS_COMMAND, 0, 0, 0, QPPS);
[0.627s] 3: -        roboclaw.setPIDConstants(M2_SET_PID_CONSTANTS_COMMAND, 0, 0, 0, QPPS);
[0.627s] 3: -        roboclaw.resetEncoders();
[0.627s] 3: -    }
[0.627s] 3: -
[0.627s] 3: -    void driver_callback(const custom_interfaces::msg::DriverVelocity& msg) {
[0.628s] 3: -        if (estop_active_) {
[0.628s] 3: -            RCLCPP_WARN(get_logger(), "E-stop is active. Ignoring motor commands.");
[0.628s] 3: -            return;
[0.628s] 3: -        }
[0.628s] 3: -
[0.628s] 3: -        double M1_counts_per_sec = velocity_to_counts_per_sec(msg.m1_vel);
[0.628s] 3: -        double M2_counts_per_sec = velocity_to_counts_per_sec(msg.m2_vel);
[0.628s] 3: -
[0.628s] 3: -        if (!roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, M1_counts_per_sec)) {
[0.628s] 3: -            RCLCPP_ERROR(get_logger(), "Failed to send command to M1 motor");
[0.628s] 3: -        }
[0.628s] 3: -        if (!roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, M2_counts_per_sec)) {
[0.628s] 3: -            RCLCPP_ERROR(get_logger(), "Failed to send command to M2 motor");
[0.628s] 3: -        }
[0.629s] 3: -    }
[0.629s] 3: -
[0.629s] 3: -    void estop_callback(const std_msgs::msg::Bool::SharedPtr msg) {
[0.629s] 3: -        estop_active_ = msg->data;
[0.629s] 3: -
[0.629s] 3: -        if (estop_active_) {
[0.629s] 3: -            RCLCPP_WARN(get_logger(), "E-stop activated. Stopping all motors.");
[0.629s] 3: -
[0.629s] 3: -            // Send zero velocity commands to stop motors
[0.629s] 3: -            roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, 0);
[0.629s] 3: -            roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, 0);
[0.629s] 3: -        } else {
[0.629s] 3: -            RCLCPP_INFO(get_logger(), "E-stop deactivated. Resuming normal operation.");
[0.629s] 3: -        }
[0.629s] 3: -    }
[0.630s] 3: +  RoboclawDriver roboclaw;
[0.630s] 3: +  double crawler_circumference_;
[0.630s] 3: +  int counts_per_rev_;
[0.630s] 3: +  int gearhead_ratio_;
[0.630s] 3: +  int pulley_ratio_;
[0.630s] 3: +  double counts_per_meter_;
[0.631s] 3: +  bool estop_active_ = false;    // E-stop state
[0.631s] 3: +
[0.631s] 3: +  rclcpp::Subscription<custom_interfaces::msg::DriverVelocity>::SharedPtr subscription_;
[0.631s] 3: +  rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr estop_subscription_;
[0.631s] 3: +
[0.631s] 3: +  double velocity_to_counts_per_sec(double velocity) const
[0.631s] 3: +  {
[0.632s] 3: +    return velocity * counts_per_meter_;
[0.632s] 3: +  }
[0.633s] 3: +
[0.633s] 3: +  void init()
[0.633s] 3: +  {
[0.633s] 3: +    roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, 0);
[0.633s] 3: +    roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, 0);
[0.633s] 3: +    roboclaw.setPIDConstants(M1_SET_PID_CONSTANTS_COMMAND, 0, 0, 0, QPPS);
[0.633s] 3: +    roboclaw.setPIDConstants(M2_SET_PID_CONSTANTS_COMMAND, 0, 0, 0, QPPS);
[0.633s] 3: +    roboclaw.resetEncoders();
[0.633s] 3: +  }
[0.634s] 3: +
[0.634s] 3: +  void driver_callback(const custom_interfaces::msg::DriverVelocity & msg)
[0.634s] 3: +  {
[0.634s] 3: +    if (estop_active_) {
[0.634s] 3: +      RCLCPP_WARN(get_logger(), "E-stop is active. Ignoring motor commands.");
[0.634s] 3: +      return;
[0.634s] 3: +    }
[0.634s] 3: +
[0.634s] 3: +    double M1_counts_per_sec = velocity_to_counts_per_sec(msg.m1_vel);
[0.634s] 3: +    double M2_counts_per_sec = velocity_to_counts_per_sec(msg.m2_vel);
[0.634s] 3: +
[0.634s] 3: +    if (!roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, M1_counts_per_sec)) {
[0.635s] 3: +      RCLCPP_ERROR(get_logger(), "Failed to send command to M1 motor");
[0.635s] 3: +    }
[0.635s] 3: +    if (!roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, M2_counts_per_sec)) {
[0.635s] 3: +      RCLCPP_ERROR(get_logger(), "Failed to send command to M2 motor");
[0.635s] 3: +    }
[0.635s] 3: +  }
[0.635s] 3: +
[0.635s] 3: +  void estop_callback(const std_msgs::msg::Bool::SharedPtr msg)
[0.635s] 3: +  {
[0.635s] 3: +    estop_active_ = msg->data;
[0.635s] 3: +
[0.636s] 3: +    if (estop_active_) {
[0.636s] 3: +      RCLCPP_WARN(get_logger(), "E-stop activated. Stopping all motors.");
[0.636s] 3: +
[0.636s] 3: +      // Send zero velocity commands to stop motors
[0.636s] 3: +      roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, 0);
[0.636s] 3: +      roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, 0);
[0.636s] 3: +    } else {
[0.636s] 3: +      RCLCPP_INFO(get_logger(), "E-stop deactivated. Resuming normal operation.");
[0.636s] 3: +    }
[0.636s] 3: +  }
[0.636s] 3: @@ -188,5 +208,6 @@
[0.636s] 3: -int main(int argc, char* argv[]) {
[0.636s] 3: -    rclcpp::init(argc, argv);
[0.637s] 3: -    rclcpp::spin(std::make_shared<Driver>());
[0.637s] 3: -    rclcpp::shutdown();
[0.637s] 3: -    return 0;
[0.637s] 3: +int main(int argc, char * argv[])
[0.637s] 3: +{
[0.637s] 3: +  rclcpp::init(argc, argv);
[0.637s] 3: +  rclcpp::spin(std::make_shared<Driver>());
[0.637s] 3: +  rclcpp::shutdown();
[0.637s] 3: +  return 0;
[0.637s] 3: 
[0.637s] 3: 1 files with code style divergence
[0.637s] 3: -- run_test.py: return code 1
[0.637s] 3: -- run_test.py: verify result file '/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/uncrustify.xunit.xml'
[0.637s] 3/4 Test #3: uncrustify .......................***Failed    0.21 sec
[0.637s] -- run_test.py: invoking following command in '/root/working/rodep_ros2/yano_ws/src/driver':
[0.637s]  - /opt/ros/humble/bin/ament_uncrustify --xunit-file /root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/uncrustify.xunit.xml
[0.638s] Code style divergence in file 'src/driver.cpp':
[0.638s] 
[0.638s] --- src/driver.cpp
[0.638s] +++ src/driver.cpp.uncrustify
[0.638s] @@ -6 +6 @@
[0.638s] -#include <std_msgs/msg/bool.hpp> 
[0.638s] +#include <std_msgs/msg/bool.hpp>
[0.638s] @@ -27 +27,2 @@
[0.638s] -class RoboclawDriver {
[0.638s] +class RoboclawDriver
[0.638s] +{
[0.638s] @@ -29,34 +30,39 @@
[0.638s] -    explicit RoboclawDriver(const string& port) : io(), serial(io, port) {
[0.639s] -        try {
[0.639s] -            serial.set_option(serial_port_base::baud_rate(SERIAL_BAUD_RATE));
[0.639s] -            serial.set_option(serial_port_base::character_size(8));
[0.639s] -            serial.set_option(serial_port_base::parity(serial_port_base::parity::none));
[0.639s] -            serial.set_option(serial_port_base::stop_bits(serial_port_base::stop_bits::one));
[0.639s] -            serial.set_option(serial_port_base::flow_control(serial_port_base::flow_control::none));
[0.639s] -        } catch (const boost::system::system_error& e) {
[0.639s] -            throw runtime_error("Failed to configure serial port: " + string(e.what()));
[0.639s] -        }
[0.639s] -    }
[0.639s] -
[0.639s] -    bool setMotorVelocity(int command, double counts_per_sec) {
[0.639s] -        vector<uint8_t> data = {ROBOCLAW_ADDRESS, static_cast<uint8_t>(command)};
[0.640s] -        appendInt32(data, static_cast<int>(counts_per_sec));
[0.640s] -        appendCRC(data);
[0.640s] -        return sendRoboclawCommand(data);
[0.640s] -    }
[0.640s] -
[0.640s] -    bool setPIDConstants(int command, int K_p, int K_i, int K_d, int qpps) {
[0.640s] -        vector<uint8_t> data = {ROBOCLAW_ADDRESS, static_cast<uint8_t>(command)};
[0.640s] -        appendInt32(data, K_d);
[0.640s] -        appendInt32(data, K_p);
[0.640s] -        appendInt32(data, K_i);
[0.640s] -        appendInt32(data, qpps);
[0.640s] -        appendCRC(data);
[0.640s] -        return sendRoboclawCommand(data);
[0.640s] -    }
[0.640s] -
[0.640s] -    bool resetEncoders() {
[0.641s] -        vector<uint8_t> data = {ROBOCLAW_ADDRESS, RESET_QUAD_ENCODER};
[0.641s] -        appendCRC(data);
[0.641s] -        return sendRoboclawCommand(data);
[0.641s] -    }
[0.641s] +  explicit RoboclawDriver(const string & port)
[0.641s] +  : io(), serial(io, port)
[0.641s] +  {
[0.641s] +    try {
[0.641s] +      serial.set_option(serial_port_base::baud_rate(SERIAL_BAUD_RATE));
[0.641s] +      serial.set_option(serial_port_base::character_size(8));
[0.641s] +      serial.set_option(serial_port_base::parity(serial_port_base::parity::none));
[0.641s] +      serial.set_option(serial_port_base::stop_bits(serial_port_base::stop_bits::one));
[0.641s] +      serial.set_option(serial_port_base::flow_control(serial_port_base::flow_control::none));
[0.641s] +    } catch (const boost::system::system_error & e) {
[0.641s] +      throw runtime_error("Failed to configure serial port: " + string(e.what()));
[0.642s] +    }
[0.642s] +  }
[0.642s] +
[0.642s] +  bool setMotorVelocity(int command, double counts_per_sec)
[0.642s] +  {
[0.642s] +    vector<uint8_t> data = {ROBOCLAW_ADDRESS, static_cast<uint8_t>(command)};
[0.642s] +    appendInt32(data, static_cast<int>(counts_per_sec));
[0.642s] +    appendCRC(data);
[0.642s] +    return sendRoboclawCommand(data);
[0.642s] +  }
[0.642s] +
[0.642s] +  bool setPIDConstants(int command, int K_p, int K_i, int K_d, int qpps)
[0.642s] +  {
[0.643s] +    vector<uint8_t> data = {ROBOCLAW_ADDRESS, static_cast<uint8_t>(command)};
[0.643s] +    appendInt32(data, K_d);
[0.643s] +    appendInt32(data, K_p);
[0.643s] +    appendInt32(data, K_i);
[0.643s] +    appendInt32(data, qpps);
[0.643s] +    appendCRC(data);
[0.643s] +    return sendRoboclawCommand(data);
[0.643s] +  }
[0.643s] +
[0.643s] +  bool resetEncoders()
[0.643s] +  {
[0.643s] +    vector<uint8_t> data = {ROBOCLAW_ADDRESS, RESET_QUAD_ENCODER};
[0.643s] +    appendCRC(data);
[0.643s] +    return sendRoboclawCommand(data);
[0.643s] +  }
[0.644s] @@ -65,39 +71,45 @@
[0.644s] -    io_service io;
[0.644s] -    serial_port serial;
[0.644s] -
[0.644s] -    bool sendRoboclawCommand(const vector<uint8_t>& data) {
[0.644s] -        try {
[0.644s] -            write(serial, buffer(data));
[0.644s] -            uint8_t response;
[0.644s] -            read(serial, buffer(&response, 1));
[0.644s] -            RCLCPP_DEBUG(rclcpp::get_logger("RoboclawDriver"), "Received Response: 0x%02X", response);
[0.644s] -            return true;
[0.644s] -        } catch (const boost::system::system_error& e) {
[0.644s] -            RCLCPP_ERROR(rclcpp::get_logger("RoboclawDriver"), "Serial Communication Error: %s", e.what());
[0.644s] -            return false;
[0.644s] -        }
[0.645s] -    }
[0.645s] -
[0.645s] -    uint16_t calculateCRC(const vector<uint8_t>& data) {
[0.645s] -        uint16_t crc = 0;
[0.645s] -        for (auto byte : data) {
[0.645s] -            crc ^= static_cast<uint16_t>(byte) << 8;
[0.645s] -            for (int i = 0; i < 8; i++) {
[0.645s] -                crc = (crc & 0x8000) ? (crc << 1) ^ 0x1021 : (crc << 1);
[0.645s] -            }
[0.645s] -        }
[0.645s] -        return crc;
[0.645s] -    }
[0.645s] -
[0.645s] -    // CRCËøΩÂä†
[0.645s] -    void appendCRC(vector<uint8_t>& data) {
[0.646s] -        uint16_t crc = calculateCRC(data);
[0.646s] -        data.push_back(static_cast<uint8_t>(crc >> 8));
[0.646s] -        data.push_back(static_cast<uint8_t>(crc & 0xFF));
[0.646s] -    }
[0.646s] -
[0.646s] -    void appendInt32(vector<uint8_t>& data, int value) {
[0.646s] -        for (int i = 3; i >= 0; --i) {
[0.646s] -            data.push_back(static_cast<uint8_t>((value >> (8 * i)) & 0xFF));
[0.646s] -        }
[0.646s] -    }
[0.646s] +  io_service io;
[0.646s] +  serial_port serial;
[0.646s] +
[0.646s] +  bool sendRoboclawCommand(const vector<uint8_t> & data)
[0.646s] +  {
[0.647s] +    try {
[0.647s] +      write(serial, buffer(data));
[0.647s] +      uint8_t response;
[0.647s] +      read(serial, buffer(&response, 1));
[0.647s] +      RCLCPP_DEBUG(rclcpp::get_logger("RoboclawDriver"), "Received Response: 0x%02X", response);
[0.647s] +      return true;
[0.647s] +    } catch (const boost::system::system_error & e) {
[0.647s] +      RCLCPP_ERROR(
[0.647s] +        rclcpp::get_logger("RoboclawDriver"), "Serial Communication Error: %s",
[0.647s] +        e.what());
[0.647s] +      return false;
[0.647s] +    }
[0.647s] +  }
[0.647s] +
[0.647s] +  uint16_t calculateCRC(const vector<uint8_t> & data)
[0.647s] +  {
[0.648s] +    uint16_t crc = 0;
[0.648s] +    for (auto byte : data) {
[0.648s] +      crc ^= static_cast<uint16_t>(byte) << 8;
[0.648s] +      for (int i = 0; i < 8; i++) {
[0.648s] +        crc = (crc & 0x8000) ? (crc << 1) ^ 0x1021 : (crc << 1);
[0.648s] +      }
[0.648s] +    }
[0.648s] +    return crc;
[0.648s] +  }
[0.648s] +
[0.648s] +  // CRCËøΩÂä†
[0.648s] +  void appendCRC(vector<uint8_t> & data)
[0.648s] +  {
[0.648s] +    uint16_t crc = calculateCRC(data);
[0.648s] +    data.push_back(static_cast<uint8_t>(crc >> 8));
[0.649s] +    data.push_back(static_cast<uint8_t>(crc & 0xFF));
[0.649s] +  }
[0.649s] +
[0.649s] +  void appendInt32(vector<uint8_t> & data, int value)
[0.649s] +  {
[0.649s] +    for (int i = 3; i >= 0; --i) {
[0.649s] +      data.push_back(static_cast<uint8_t>((value >> (8 * i)) & 0xFF));
[0.649s] +    }
[0.649s] +  }
[0.649s] @@ -107 +119,2 @@
[0.649s] -class Driver : public rclcpp::Node {
[0.649s] +class Driver : public rclcpp::Node
[0.649s] +{
[0.649s] @@ -109,22 +122,25 @@
[0.649s] -    Driver() : Node("driver"), roboclaw("/dev/ttyACM0") { 
[0.650s] -        declare_parameter("crawler_circumference", 0.39);
[0.650s] -        declare_parameter("counts_per_rev", 256); // quad pulses per rev = counts per rev
[0.650s] -        declare_parameter("gearhead_ratio", 66); // Ê∏õÈÄüÊØî
[0.650s] -        declare_parameter("pulley_ratio", 2);
[0.650s] -
[0.650s] -        crawler_circumference_ = get_parameter("crawler_circumference").as_double();
[0.650s] -        counts_per_rev_ = get_parameter("counts_per_rev").as_int();
[0.650s] -        gearhead_ratio_ = get_parameter("gearhead_ratio").as_int();
[0.650s] -        pulley_ratio_ = get_parameter("pulley_ratio").as_int();
[0.650s] -
[0.650s] -        // velocity„Çíqpps„Å´Â§âÊèõ„Åô„ÇãÈöõ„Å´Áî®„ÅÑ„ÇãÂÆöÊï∞
[0.650s] -        counts_per_meter_ = (counts_per_rev_ * gearhead_ratio_ * pulley_ratio_) / crawler_circumference_;
[0.650s] -
[0.650s] -        subscription_ = create_subscription<custom_interfaces::msg::DriverVelocity>(
[0.650s] -            "/operator", 10, bind(&Driver::driver_callback, this, _1));
[0.651s] -
[0.651s] -        estop_subscription_ = create_subscription<std_msgs::msg::Bool>(
[0.651s] -            "/emergency_stop", 10, bind(&Driver::estop_callback, this, _1));
[0.651s] -
[0.651s] -        init();
[0.651s] -    }
[0.651s] +  Driver()
[0.651s] +  : Node("driver"), roboclaw("/dev/ttyACM0")
[0.651s] +  {
[0.651s] +    declare_parameter("crawler_circumference", 0.39);
[0.651s] +    declare_parameter("counts_per_rev", 256);     // quad pulses per rev = counts per rev
[0.651s] +    declare_parameter("gearhead_ratio", 66);     // Ê∏õÈÄüÊØî
[0.651s] +    declare_parameter("pulley_ratio", 2);
[0.651s] +
[0.651s] +    crawler_circumference_ = get_parameter("crawler_circumference").as_double();
[0.651s] +    counts_per_rev_ = get_parameter("counts_per_rev").as_int();
[0.652s] +    gearhead_ratio_ = get_parameter("gearhead_ratio").as_int();
[0.652s] +    pulley_ratio_ = get_parameter("pulley_ratio").as_int();
[0.652s] +
[0.652s] +    // velocity„Çíqpps„Å´Â§âÊèõ„Åô„ÇãÈöõ„Å´Áî®„ÅÑ„ÇãÂÆöÊï∞
[0.652s] +    counts_per_meter_ = (counts_per_rev_ * gearhead_ratio_ * pulley_ratio_) /
[0.652s] +      crawler_circumference_;
[0.652s] +
[0.652s] +    subscription_ = create_subscription<custom_interfaces::msg::DriverVelocity>(
[0.652s] +      "/operator", 10, bind(&Driver::driver_callback, this, _1));
[0.652s] +
[0.652s] +    estop_subscription_ = create_subscription<std_msgs::msg::Bool>(
[0.652s] +      "/emergency_stop", 10, bind(&Driver::estop_callback, this, _1));
[0.652s] +
[0.652s] +    init();
[0.652s] +  }
[0.652s] @@ -133,53 +149,57 @@
[0.653s] -    RoboclawDriver roboclaw;
[0.653s] -    double crawler_circumference_;
[0.653s] -    int counts_per_rev_;
[0.653s] -    int gearhead_ratio_;
[0.653s] -    int pulley_ratio_;
[0.653s] -    double counts_per_meter_;
[0.653s] -    bool estop_active_ = false;  // E-stop state
[0.653s] -
[0.653s] -    rclcpp::Subscription<custom_interfaces::msg::DriverVelocity>::SharedPtr subscription_;
[0.653s] -    rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr estop_subscription_;
[0.653s] -
[0.653s] -    double velocity_to_counts_per_sec(double velocity) const {
[0.653s] -        return velocity * counts_per_meter_;
[0.653s] -    }
[0.653s] -
[0.653s] -    void init() {
[0.654s] -        roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, 0);
[0.654s] -        roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, 0);
[0.654s] -        roboclaw.setPIDConstants(M1_SET_PID_CONSTANTS_COMMAND, 0, 0, 0, QPPS);
[0.654s] -        roboclaw.setPIDConstants(M2_SET_PID_CONSTANTS_COMMAND, 0, 0, 0, QPPS);
[0.654s] -        roboclaw.resetEncoders();
[0.654s] -    }
[0.654s] -
[0.654s] -    void driver_callback(const custom_interfaces::msg::DriverVelocity& msg) {
[0.654s] -        if (estop_active_) {
[0.654s] -            RCLCPP_WARN(get_logger(), "E-stop is active. Ignoring motor commands.");
[0.654s] -            return;
[0.654s] -        }
[0.654s] -
[0.654s] -        double M1_counts_per_sec = velocity_to_counts_per_sec(msg.m1_vel);
[0.654s] -        double M2_counts_per_sec = velocity_to_counts_per_sec(msg.m2_vel);
[0.654s] -
[0.655s] -        if (!roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, M1_counts_per_sec)) {
[0.655s] -            RCLCPP_ERROR(get_logger(), "Failed to send command to M1 motor");
[0.655s] -        }
[0.655s] -        if (!roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, M2_counts_per_sec)) {
[0.655s] -            RCLCPP_ERROR(get_logger(), "Failed to send command to M2 motor");
[0.655s] -        }
[0.655s] -    }
[0.655s] -
[0.655s] -    void estop_callback(const std_msgs::msg::Bool::SharedPtr msg) {
[0.655s] -        estop_active_ = msg->data;
[0.655s] -
[0.655s] -        if (estop_active_) {
[0.655s] -            RCLCPP_WARN(get_logger(), "E-stop activated. Stopping all motors.");
[0.656s] -
[0.656s] -            // Send zero velocity commands to stop motors
[0.656s] -            roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, 0);
[0.656s] -            roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, 0);
[0.656s] -        } else {
[0.656s] -            RCLCPP_INFO(get_logger(), "E-stop deactivated. Resuming normal operation.");
[0.656s] -        }
[0.656s] -    }
[0.656s] +  RoboclawDriver roboclaw;
[0.656s] +  double crawler_circumference_;
[0.656s] +  int counts_per_rev_;
[0.656s] +  int gearhead_ratio_;
[0.656s] +  int pulley_ratio_;
[0.656s] +  double counts_per_meter_;
[0.656s] +  bool estop_active_ = false;    // E-stop state
[0.656s] +
[0.657s] +  rclcpp::Subscription<custom_interfaces::msg::DriverVelocity>::SharedPtr subscription_;
[0.657s] +  rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr estop_subscription_;
[0.657s] +
[0.657s] +  double velocity_to_counts_per_sec(double velocity) const
[0.657s] +  {
[0.657s] +    return velocity * counts_per_meter_;
[0.657s] +  }
[0.657s] +
[0.657s] +  void init()
[0.657s] +  {
[0.657s] +    roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, 0);
[0.657s] +    roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, 0);
[0.657s] +    roboclaw.setPIDConstants(M1_SET_PID_CONSTANTS_COMMAND, 0, 0, 0, QPPS);
[0.657s] +    roboclaw.setPIDConstants(M2_SET_PID_CONSTANTS_COMMAND, 0, 0, 0, QPPS);
[0.657s] +    roboclaw.resetEncoders();
[0.657s] +  }
[0.658s] +
[0.658s] +  void driver_callback(const custom_interfaces::msg::DriverVelocity & msg)
[0.658s] +  {
[0.658s] +    if (estop_active_) {
[0.658s] +      RCLCPP_WARN(get_logger(), "E-stop is active. Ignoring motor commands.");
[0.658s] +      return;
[0.658s] +    }
[0.658s] +
[0.658s] +    double M1_counts_per_sec = velocity_to_counts_per_sec(msg.m1_vel);
[0.658s] +    double M2_counts_per_sec = velocity_to_counts_per_sec(msg.m2_vel);
[0.659s] +
[0.659s] +    if (!roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, M1_counts_per_sec)) {
[0.659s] +      RCLCPP_ERROR(get_logger(), "Failed to send command to M1 motor");
[0.659s] +    }
[0.659s] +    if (!roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, M2_counts_per_sec)) {
[0.659s] +      RCLCPP_ERROR(get_logger(), "Failed to send command to M2 motor");
[0.659s] +    }
[0.659s] +  }
[0.659s] +
[0.660s] +  void estop_callback(const std_msgs::msg::Bool::SharedPtr msg)
[0.660s] +  {
[0.660s] +    estop_active_ = msg->data;
[0.660s] +
[0.660s] +    if (estop_active_) {
[0.660s] +      RCLCPP_WARN(get_logger(), "E-stop activated. Stopping all motors.");
[0.660s] +
[0.660s] +      // Send zero velocity commands to stop motors
[0.660s] +      roboclaw.setMotorVelocity(M1_MOTOR_COMMAND, 0);
[0.660s] +      roboclaw.setMotorVelocity(M2_MOTOR_COMMAND, 0);
[0.661s] +    } else {
[0.661s] +      RCLCPP_INFO(get_logger(), "E-stop deactivated. Resuming normal operation.");
[0.661s] +    }
[0.661s] +  }
[0.661s] @@ -188,5 +208,6 @@
[0.661s] -int main(int argc, char* argv[]) {
[0.661s] -    rclcpp::init(argc, argv);
[0.662s] -    rclcpp::spin(std::make_shared<Driver>());
[0.662s] -    rclcpp::shutdown();
[0.662s] -    return 0;
[0.662s] +int main(int argc, char * argv[])
[0.662s] +{
[0.662s] +  rclcpp::init(argc, argv);
[0.662s] +  rclcpp::spin(std::make_shared<Driver>());
[0.663s] +  rclcpp::shutdown();
[0.663s] +  return 0;
[0.663s] 
[0.663s] 1 files with code style divergence
[0.663s] -- run_test.py: return code 1
[0.663s] -- run_test.py: verify result file '/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/uncrustify.xunit.xml'
[0.664s] 
[0.664s] test 4
[0.664s]     Start 4: xmllint
[0.664s] 
[0.664s] 4: Test command: /usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/xmllint.xunit.xml" "--package-name" "driver" "--output-file" "/root/working/rodep_ros2/yano_ws/build/driver/ament_xmllint/xmllint.txt" "--command" "/opt/ros/humble/bin/ament_xmllint" "--xunit-file" "/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/xmllint.xunit.xml"
[0.664s] 4: Test timeout computed to be: 60
[0.706s] 4: -- run_test.py: invoking following command in '/root/working/rodep_ros2/yano_ws/src/driver':
[0.706s] 4:  - /opt/ros/humble/bin/ament_xmllint --xunit-file /root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/xmllint.xunit.xml
[1.295s] 4: File 'package.xml' is valid
[1.295s] 4: 
[1.295s] 4: No problems found
[1.307s] 4: -- run_test.py: return code 0
[1.307s] 4: -- run_test.py: verify result file '/root/working/rodep_ros2/yano_ws/build/driver/test_results/driver/xmllint.xunit.xml'
[1.318s] 4/4 Test #4: xmllint ..........................   Passed    0.69 sec
[1.318s] 
[1.319s] 50% tests passed[0;0m, [0;31m2 tests failed[0;0m out of 4
[1.319s] 
[1.319s] Label Time Summary:
[1.319s] cppcheck      =   0.19 sec*proc (1 test)
[1.319s] lint_cmake    =   0.18 sec*proc (1 test)
[1.319s] linter        =   1.28 sec*proc (4 tests)
[1.319s] uncrustify    =   0.21 sec*proc (1 test)
[1.319s] xmllint       =   0.69 sec*proc (1 test)
[1.319s] 
[1.319s] Total Test time (real) =   1.28 sec
[1.319s] 
[1.319s] The following tests FAILED:
[1.319s] 	[0;31m  2 - lint_cmake (Failed)[0;0m
[1.319s] 	[0;31m  3 - uncrustify (Failed)[0;0m
[1.320s] Errors while running CTest
[1.322s] Invoked command in '/root/working/rodep_ros2/yano_ws/build/driver' returned '8': AMENT_PREFIX_PATH=/root/working/rodep_ros2/yano_ws/install/driver:/root/working/rodep_ros2/yano_ws/install/custom_interfaces:${AMENT_PREFIX_PATH} CMAKE_PREFIX_PATH=/root/working/rodep_ros2/yano_ws/install/driver:/root/working/rodep_ros2/yano_ws/install/custom_interfaces LD_LIBRARY_PATH=/root/working/rodep_ros2/yano_ws/install/custom_interfaces/lib:${LD_LIBRARY_PATH} PYTHONPATH=/root/working/rodep_ros2/yano_ws/install/custom_interfaces/local/lib/python3.10/dist-packages:${PYTHONPATH} /usr/bin/ctest -C Release -D ExperimentalTest --no-compress-output -V --force-new-ctest-process --output-on-failure
